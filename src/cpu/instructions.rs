/*
 * Opcodes from: http://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html
 *
 * d8   - immediate 8-bit data
 * d16  - immediate 16-bit data
 * a8   - 8-bit unsigned data, added to $FF00 in certain instr. (replacement for missing IN/OUT
 *          instructions)
 * a16  - 16-bit address
 * r8   - 8-bit signed data, added to PC
 *
 * +/- denoted with: _p_ or _m_ to the immediate right of symbol the sign is associated with.
 *
 * When an address is stored in a register and you need to modify data at that address, 
 * the register name (and sign-modifier) is followed by _ptr (example: LD (HL+), 4 => LD_HL_p_ptr_4)
 *
 */
#[derive(Debug, FromPrimitive)]
#[allow(non_camel_case_types)]
pub enum Instruction {
    NOP,
    LD_BC_d16,
    LD_BC_ptr_A,
    INC_BC,
    INC_B,
    DEC_B,
    LD_B_d8,
    RLCA,
    LD_a16_ptr_SP,
    ADD_HL_BC,
    LD_A_BC_ptr,
    DEC_BC,
    INC_C,
    DEC_C,
    LD_C_d8,
    RRCA,
    
    STOP_0,
    LD_DE_d16,
    LD_DE_ptr_A,
    INC_DE,
    INC_D,
    DEC_D,
    LD_D_d8,
    RLA,
    JR_r8,
    ADD_HL_DE,
    LD_A_DE_ptr,
    DEC_DE,
    INC_E,
    DEC_E,
    LD_E_d8,
    RRA,

    JR_NZ_r8,
    LD_HL_d16,
    LD_HL_p_ptr_A,    // HL+
    INC_HL,
    INC_H,
    DEC_H,
    LD_H_d8,
    DAA,
    JR_Z,r8,
    ADD_HL_HL,
    LD_A_HL_p_ptr,
    DEC_HL,
    INC_L,
    DEC_L,
    LD_L_d8,
    CPL,

    JR_NC_r8,
    LD_SP_d16,
    LD_HL_m_ptr_A,    // HL-
    INC_SP,
    INC_HL_ptr,     //(HL)
    DEC_HL_ptr,
    LD_HL_ptr_d8,
    SCF,
    JR_C_r8,
    ADD_HL_SP,
    LD_A_HL_m_ptr,
    DEC_SP,
    INC_A,
    DEC_A,
    LD_A_d8,
    CCF,

    LD_B_B,
    LD_B_C,
    LD_B_D,
    LD_B_E,
    LD_B_H,
    LD_B_L,
    LD_B_HL_ptr,
    LD_B_A,
    LD_C_B,
    LD_C_C,
    LD_C_D,
    LD_C_E,
    LD_C_H,
    LD_C_L,
    LD_C_HL_ptr,
    LD_C_A,

    LD_D_B,
    LD_D_C,
    LD_D_D,
    LD_D_E,
    LD_D_H,
    LD_D_L,
    LD_D_HL_ptr,
    LD_D_A,
    LD_E_B,
    LD_E_C,
    LD_E_D,
    LD_E_E,
    LD_E_H,
    LD_E_L,
    LD_E_HL_ptr,
    LD_E_A,

    LD_H_B,
    LD_H_C,
    LD_H_D,
    LD_H_E,
    LD_H_H,
    LD_H_L,
    LD_H_HL_ptr,
    LD_H_A,
    LD_L_B,
    LD_L_C,
    LD_L_D,
    LD_L_E,
    LD_L_H,
    LD_L_L,
    LD_L_HL_ptr,
    LD_L_A,

    LD_HL_ptr_B,
    LD_HL_ptr_C,
    LD_HL_ptr_D,
    LD_HL_ptr_E,
    LD_HL_ptr_H,
    LD_HL_ptr_L,
    HALT,
    LD_HL_ptr_A,
    LD_A_B,
    LD_A_C,
    LD_A_D,
    LD_A_E,
    LD_A_H,
    LD_A_L,
    LD_A_HL_ptr,
    LD_A_A,

    ADD_A_B,
    ADD_A_C,
    ADD_A_D,
    ADD_A_E,
    ADD_A_H,
    ADD_A_L,
    ADD_A_HL_ptr,
    ADD_A_A,
    ADC_A_B,
    ADC_A_C,
    ADC_A_D,
    ADC_A_E,
    ADC_A_H,
    ADC_A_L,
    ADC_A_HL_ptr,
    ADC_A_A,

    SUB_B,
    SUB_C,
    SUB_D,
    SUB_E,
    SUB_H,
    SUB_L,
    SUB_HL_ptr,
    SUB_A,
    SBC_A_B,
    SBC_A_C,
    SBC_A_D,
    SBC_A_E,
    SBC_A_H,
    SBC_A_L,
    SBC_A_HL_ptr,
    SBC_A_A,

    AND_B,
    AND_C,
    AND_D,
    AND_E,
    AND_H,
    AND_L,
    AND_HL_ptr,
    AND_A,
    XOR_B,
    XOR_C,
    XOR_D,
    XOR_E,
    XOR_H,
    XOR_L,
    XOR_HL_ptr,
    XOR_A,

    OR_B,
    OR_C,
    OR_D,
    OR_E,
    OR_H,
    OR_L,
    OR_HL_ptr,
    OR_A,
    CP_B,
    CP_C,
    CP_D,
    CP_E,
    CP_H,
    CP_L,
    CP_HL_ptr,
    CP_A,

    RET_NZ,
    POP_BC,
    JP_NZ_a16,
    JP_a16,
    CALL_NZ_a16,
    PUSH_BC,
    ADD_A_d8,
    RST_00H,
    RET_Z,
    RET,
    JP_Z_a16,
    PREFIX_CB,
    CALL_Z_a16,
    CALL_a16,
    ADC_A_d8,
    RST_08H,
    
    RET_NC,
    POP_DE,
    JP_NC_a16,
    DEAD_OP1,
    CALL_NC_a16,
    PUSH_DE,
    SUB_d8,
    RST_10H,
    RET_C,
    RETI,
    JP_C_a16,
    DEAD_OP2,
    CALL_C_a16,
    DEAD_OP3,
    SBC_A_d8,
    RST_18H,

    LDH_a8_ptr_A,
    POP_HL,
    LD_C_ptr_A,
    DEAD_OP4,
    DEAD_OP5,
    PUSH_HL,
    AND_d8,
    RST_20H,
    ADD_SP_r8,
    JP_HL_ptr,
    LD_a16_ptr_A,
    DEAD_OP6,
    DEAD_OP7,
    DEAD_OP8,
    XOR_d8,
    RST_28H,

    LDH_A_a8_ptr,
    POP_AF,
    LD_A_C_ptr,
    DI,
    DEAD_OP9,
    PUSH_AF,
    OR_d8,
    RST_30H,
    LD_HL_SP_p_r8,
    LD_SP_HL,
    LD_A_a16_ptr,
    EI,
    DEAD_OP10,
    DEAD_OP11,
    CP_d8,
    RST_38H,
}

impl Instruction {
    pub fn from_u32(value: u32) -> Option<Self> {
        num::FromPrimitive::from_u32(value)
    }
}
